const addWinGo = async (game) => {
  try {
    let join = '';
    if (game == 1) join = 'wingo';
    if (game == 3) join = 'wingo3';
    if (game == 5) join = 'wingo5';
    if (game == 10) join = 'wingo10';

    const [winGoNow] = await connection.query(`SELECT period FROM wingo WHERE status = 0 AND game = "${join}" ORDER BY id DESC LIMIT 1 `);
    const [setting] = await connection.query('SELECT * FROM `admin` ');
    let period = winGoNow.length > 0 ? winGoNow[0].period : null;
    let amount = Math.floor(Math.random() * 10);
    const [minPlayers] = await connection.query(`SELECT * FROM minutes_1 WHERE status = 0 AND game = "${join}"`);

    // Logika untuk menentukan hasil permainan tetap sesuai dengan logika yang ada
    if (minPlayers.length >= 2) {
      // ... (logika yang ada untuk menentukan hasil permainan)
    } else if (minPlayers.length === 1 && parseFloat(minPlayers[0].money) >= 20) {
      // ... (logika yang ada untuk menentukan hasil permainan)
    }

    let timeNow = Date.now();
    let nextResult = '';
    if (game == 1) nextResult = setting[0].wingo1;
    if (game == 3) nextResult = setting[0].wingo3;
    if (game == 5) nextResult = setting[0].wingo5;
    if (game == 10) nextResult = setting[0].wingo10;

    let newArr = '';
    if (nextResult == '-1') {
      await connection.execute(`UPDATE wingo SET amount = ?,status = ? WHERE period = ? AND game = "${join}"`, [amount, 1, period]);
      newArr = '-1';
    } else {
      let result = '';
      let arr = nextResult.split('|');
      let check = arr.length;
      if (check == 1) {
        newArr = '-1';
      } else {
        for (let i = 1; i < arr.length; i++) {
          newArr += arr[i] + '|';
        }
        newArr = newArr.slice(0, -1);
      }
      result = arr[0];
      await connection.execute(`UPDATE wingo SET amount = ?,status = ? WHERE period = ? AND game = "${join}"`, [result, 1, period]);
    }
    // ambil data yang sesuai panel controller
    const sql = `INSERT INTO wingo SET 
    period = ?,
    amount = ?,
    game = ?,
    status = ?,
    time = ?`;

    await connection.execute(sql, [Number(period) + 1, 0, join, 0, timeNow]);

    if (game == 1) join = 'wingo1';
    if (game == 3) join = 'wingo3';
    if (game == 5) join = 'wingo5';
    if (game == 10) join = 'wingo10';

    await connection.execute(`UPDATE admin SET ${join} = ?`, [newArr]);

    // Informasi hasil periode saat ini
    //const resultMessage = `Periode ${period} hasil ${amount >= 5 ? 'Big' : 'Small'} ${amount}`;
    //await sendTelegramMessage(resultMessage);

    // Kirim prediksi acak ke Telegram untuk periode berikutnya
    const pattern = ['b', 'b', 'k', 'b', 'k', 'k', 'b', 'b', 'b', 'b', 'k', 'k'];
    for (let i = pattern.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pattern[i], pattern[j]] = [pattern[j], pattern[i]];
    }
    const randomPrediction = pattern[Math.floor(Math.random() * pattern.length)];
    const nextPeriod = Number(period) + 1;
    const predictionMessage = `üéØ Wingo Platinum üéØ\nüìå Periode: ${nextPeriod}\nüîÆ Prediksi: ${randomPrediction === 'b' ? 'Big' : 'Small'}\nüçÄ Semoga beruntung! üöÄ`;

    await sendTelegramMessage(predictionMessage);


  } catch (error) {
    if (error) {
      console.log(error);
    }
  }
}


const addWinGo = async (game) => {
    try {
        let join = '';
        if (game == 1) join = 'wingo';
        if (game == 3) join = 'wingo3';
        if (game == 5) join = 'wingo5';
        if (game == 10) join = 'wingo10';

        const [winGoNow] = await connection.query(`SELECT period FROM wingo WHERE status = 0 AND game = "${join}" ORDER BY id DESC LIMIT 1 `);
        const [setting] = await connection.query('SELECT * FROM `admin` ');
        // Ensure winGoNow is not empty before accessing its first element
        let period = winGoNow.length > 0 ? winGoNow[0].period : null;
        let amount = Math.floor(Math.random() * 10);
        const [minPlayers] = await connection.query(`SELECT * FROM minutes_1 WHERE status = 0 AND game = "${join}"`);
        if (minPlayers.length >= 2) {
            const betColumns = [
                // red_small 
                { name: 'red_0', bets: ['0', 't', 'd', 'n'] },
                { name: 'red_2', bets: ['2', 'd', 'n'] },
                { name: 'red_4', bets: ['4', 'd', 'n'] },
                // green small 
                { name: 'green_1', bets: ['1', 'x', 'n'] },
                { name: 'green_3', bets: ['3', 'x', 'n'] },
                // green big 
                { name: 'green_5', bets: ['5', 'x', 't', 'l'] },
                { name: 'green_7', bets: ['7', 'x', 'l'] },
                { name: 'green_9', bets: ['9', 'x', 'l'] },
                // red big 
                { name: 'red_6', bets: ['6', 'd', 'l'] },
                { name: 'red_8', bets: ['8', 'd', 'l'] }
            ];

            const totalMoneyPromises = betColumns.map(async column => {
                const [result] = await connection.query(`
                SELECT SUM(money) AS total_money
                FROM minutes_1
                WHERE game = "${join}" AND status = 0 AND bet IN (${column.bets.map(bet => `"${bet}"`).join(',')})
            `);
                return { name: column.name, total_money: result[0].total_money ? parseInt(result[0].total_money) : 0 };
            });

            const categories = await Promise.all(totalMoneyPromises);
            let smallestCategory = categories.reduce((smallest, category) =>
                (smallest === null || category.total_money < smallest.total_money) ? category : smallest
                , null);
            const colorBets = {
                red_6: [6],
                red_8: [8],
                red_2: [2], //0 removed 
                red_4: [4],
                green_3: [3],
                green_7: [7], //5 removed
                green_9: [9], //
                green_1: [1],
                green_5: [5],
                red_0: [0],
            };

            const betsForCategory = colorBets[smallestCategory.name] || [];
            const availableBets = betsForCategory.filter(bet =>
                !categories.find(category => category.name === smallestCategory.name && category.total_money < smallestCategory.total_money)
            );
            let lowestBet;
            if (availableBets.length > 0) {
                lowestBet = availableBets[0];
            } else {
                lowestBet = betsForCategory.reduce((lowest, bet) =>
                    (bet < lowest) ? bet : lowest
                );
            }

            amount = lowestBet;
        } else if (minPlayers.length === 1 && parseFloat(minPlayers[0].money) >= 20) {
            const betColumns = [
                { name: 'red_small', bets: ['0', '2', '4', 'd', 'n'] },
                { name: 'red_big', bets: ['6', '8', 'd', 'l'] },
                { name: 'green_big', bets: ['5', '7', '9', 'x', 'l'] },
                { name: 'green_small', bets: ['1', '3', 'x', 'n'] },
                { name: 'violet_small', bets: ['0', 't', 'n'] },
                { name: 'violet_big', bets: ['5', 't', 'l'] }
            ];

            const categories = await Promise.all(betColumns.map(async column => {
                const [result] = await connection.query(`
                    SELECT SUM(money) AS total_money
                    FROM minutes_1
                    WHERE game = "${join}" AND status = 0 AND bet IN (${column.bets.map(bet => `"${bet}"`).join(',')})
                `);
                return { name: column.name, total_money: parseInt(result[0]?.total_money) || 0 };
            }));

            const colorBets = {
                red_big: [6, 8],
                red_small: [2, 4], //0 removed 
                green_big: [7, 9], //5 removed
                green_small: [1, 3],
                violet_big: [5],
                violet_small: [0],
            };

            const smallestCategory = categories.reduce((smallest, category) =>
                (!smallest || category.total_money < smallest.total_money) ? category : smallest
            );

            const betsForCategory = colorBets[smallestCategory.name] || [];
            const availableBets = betsForCategory.filter(bet =>
                !categories.find(category => category.name === smallestCategory.name && category.total_money < smallestCategory.total_money)
            );

            const lowestBet = availableBets.length > 0 ? availableBets[0] : Math.min(...betsForCategory);
            amount = lowestBet;
        }

        // xanh ƒë·ªè t√≠m
        let timeNow = Date.now();

        let nextResult = '';
        if (game == 1) nextResult = setting[0].wingo1;
        if (game == 3) nextResult = setting[0].wingo3;
        if (game == 5) nextResult = setting[0].wingo5;
        if (game == 10) nextResult = setting[0].wingo10;

        let newArr = '';
        if (nextResult == '-1') {
            await connection.execute(`UPDATE wingo SET amount = ?,status = ? WHERE period = ? AND game = "${join}"`, [amount, 1, period]);
            newArr = '-1';
        } else {
            let result = '';
            let arr = nextResult.split('|');
            let check = arr.length;
            if (check == 1) {
                newArr = '-1';
            } else {
                for (let i = 1; i < arr.length; i++) {
                    newArr += arr[i] + '|';
                }
                newArr = newArr.slice(0, -1);
            }
            result = arr[0];
            await connection.execute(`UPDATE wingo SET amount = ?,status = ? WHERE period = ? AND game = "${join}"`, [result, 1, period]);
        }
        const sql = `INSERT INTO wingo SET 
        period = ?,
        amount = ?,
        game = ?,
        status = ?,
        time = ?`;

        await connection.execute(sql, [Number(period) + 1, 0, join, 0, timeNow]);

        if (game == 1) join = 'wingo1';
        if (game == 3) join = 'wingo3';
        if (game == 5) join = 'wingo5';
        if (game == 10) join = 'wingo10';

        await connection.execute(`UPDATE admin SET ${join} = ?`, [newArr]);
    } catch (error) {
        if (error) {
            console.log(error);
        }
    }
}